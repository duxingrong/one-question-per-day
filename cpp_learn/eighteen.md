# map
我们常常把map称之为映射，就是将一个元素(通常称之为key健)与一个相对应的值(通常称之为value)关联起来，比如说一个学生的姓名(key)有与之对应的成绩(value)，它们是一一对应的，就好像一把钥匙开一扇门，在map中健是唯一的，也只有一个唯一的确定的值

C++中,map提供了以下三种数据结构，其底蕴实现以及优劣如下

map中的健是唯一的，但是multimap则没有此限制

std::unordered_map的key值存储是无序的，底层实现是哈希表，查找速度更快，如果不需要排序而只是快速查找健对应的值，可以考虑使用

std::map 和std::mulimap的底层实现是红黑树，它的key值存储是有序的，如果需要对健值对进行自定义排序，可以考虑std::map

```c++
#include <unordered_map>
#include <map>
```

想要声明map映射关系，需要指定健的类型和值的类型
```C++
unordered_map<int,int> uMap;
map<string,int> myMap;
```

想要插入健值对key-value,需要使用insert()函数或者使用[]操作符来插入，如果键不存在，[]操作符将会创建一个新的键值对，将其插入到map中，并将值初始化为默认值(对于整数来说，默认值为0)
```c++
uMap[0]=10;
uMap[10]=0;

myMap["math"]=100;
myMap["english"]=80;
```

map可以使用find函数来检查某个健是否存在于map中，它会返回一个迭代器，如果存在，指向该健值对，否则指向map的末尾
```c++
if (myMap.find("math")!=myMap.end()){
    //存在
}else{
    //不存在
}
```

使用范围for循环来遍历map中的所有键值对
```c++
for(const pair<int,int>&kv:umap){

}
```
当使用范围for循环来遍历map时，我们需要声明一个变量kv来存储每个健值对，这个变量的类型通常是pair类型

`const`用于声明一个不可修改的变量，这意味着一旦变量被初始化，就不能再修改其值，常量通常用大写字母表示
因为const声明的变量一旦创建后就无法修改值，所以必须初始化
```c++
const double PI = 3.1415926;
//const关键字表示你只能读取容器中的元素，而不能修改它们
```

pair<int,int>定义了kv也就是健值对的类型是pair
C++中pair类型会将两个不同的值组合成一个单元，常用于存储健值对，创建pair的时候，必须提供两个类型名，在使用的时候，通过first和second成员来访问pair中的第一个和第二个元素，它的first成员存储健，second成员存储值

&:这个符号表示kv是一个引用(reference),而不是值的拷贝,如果不使用引用的话，那在每次循环迭代中都会重新创建一个新的pair对象来复制健值对，而这个会导致不必要的内存分配和拷贝操作

# 范围for循环
C++中引入了范围for循环，用于更方便地遍历容器中的元素，这种循环提供了一种简单的方式来迭代容器中的每个元素，而不需要显式地使用迭代器或者索引
```C++
for (类型 变量名: 容器){

}
```
```C++
std::vector<int> numbers ={1,2,3,4,5};
for (int num:numbers){
    std::cout<<num::" ";
}
```
范围for循环不会修改容器中的元素，它只用于读取元素，如果需要修改容器中的元素，需要使用传统的for循环,或者其他迭代方式







