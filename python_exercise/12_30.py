"""
正则表达式匹配

给你一个字符串s和一个字符串规律p,请你来实现一个支持'.'和'*'的正则表达式匹配

'.'匹配任意单个字符
'*'匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖整个字符串s的,而不是部分字符串

s='' ,p='a*' 
true 因为匹配0次，代表把a移除去


s='aa',p='a*'
true 因为*代表可以匹配零个或多个前面的a元素

s='ab' p ='.*'
true 因为*代表多个'.',而'.'有可以代表任意字符



动态规划
bool dp[i][j] 表示s[:i]和p[:j]是否匹配

第推公式:
如果s[i-1]==p[j-1] or p[j-1]=='.' 那么dp[i][j]由dp[i-1][j-1]决定
如果p[j-1]=='*': 
- 如果使用匹配0次,就是相当于删掉*和p[j-2]，所以是否匹配取决于dp[i][j-2]
- 如果使用匹配多次,这里是最难理解的，反正现在的我还是不理解,
    这里匹配多次的前提是: 当前的字符需要先匹配,因为'*'可以是它前面的字符,所以单前匹配的意思就是s[i-1]==p[j-2]或者p[j-2]='.',在此基础上，dp[i][j]是否匹配取决于前面的字符串是否与p[:j]想；匹配,这里为什么还是p[:j]呢?我的理解是因为*可以代表多个前面的字符嘛,所以当前这一次的匹配，消耗不掉*这个字符，他将继续去和之前的字符匹配,所以最终在这种情况下的第推公式是:
    dp[i][j]= dp[i-1][j] and (s[i-1]==p[j-2] or p[j-2]==".")

    这确实很难理解，但是我相信再次见到这段话的你，肯定比现在的我更加理解
"""

class Solution():
    def isMatch(self,s:str,p:str)->bool:
        m = len(s)
        n = len(p)

        #dp数组
        dp = [[False]*(n+1) for _ in range(m+1)]
        
        #初始化
        dp[0][0]=True #很显然，两个都为空当然是True
        #需要更新dp数组,因为有情况可以匹配空的s
        for j in range(2,n+1):
            if p[j-1]=='*':
                dp[0][j]=dp[0][j-2]

        #开始第推
        for i in range(1,m+1): #因为第推公式中有
            for j in range(1,n+1):
                if s[i-1]==p[j-1] or p[j-1]=='.':
                    dp[i][j]=dp[i-1][j-1]
                elif p[j-1]=="*":
                    dp[i][j]= dp[i][j-2] or (dp[i-1][j] and (s[i-1]==p[j-2] or p[j-2]=='.'))

        # print(dp)
        return dp[-1][-1]

if __name__=="__main__":
    s='aa'
    p='a*'   
    solution = Solution()
    print(solution.isMatch(s,p))













