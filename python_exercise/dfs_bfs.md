# dfs和bfs的区别
两者大概的区别:
dfs是可一个方向去搜索，不到黄河不回头，知道遇到绝境了，搜不下去了，再换方向(换方向的过程就涉及到了回溯).
bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，西面八方的搜索过程


# dfs关键就两点:
1. 搜索方向，是认准一个方向搜，直到碰壁后再换方向
2. 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程


# 代码框架
正是因为dfs搜索是可一个方向，并需要回溯，所以用递归的方式来实现是最方便的
```C++
void dfs(参数){
    处理节点
    dfs(图，选择的节点);//递归
    回溯，撤销处理结果
}
```
回溯操作就在递归函数的下面，递归和回溯是相辅相成的

dfs和bfs其实就是基础搜索语法，广泛应用于其他数据结构与算法中.
```c++
void dfs(参数){
    if(终止条件){
        存放结果;
        return ;
    }
    for( 选择:本节点所连接的其他节点){
        处理节点;
        dfs(图，选择的节点);//递归
        回溯，撤销处理结果
    }
}
```

# 深搜三部曲
第一:
确认递归函数，参数
```c++
void dfs(参数)
```
一般情况，深搜需要二维数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量,避免函数过多
```c++
vector<vector<int>> result; //保存符合条件的所有路径
vector<int> path; //起点到终点的路径
void dfs(图，目前搜索的节点)
```
第二:
确认终止条件
```c++
if (终止条件){
    存放结果;
    return ;
}
```
终止条件不仅是结束本层递归,同时也是我们收获结果的时候
有很多dfs写法，没有写终止条件，是因为如果不符合条件的话，直接不会向下递归

第三:
处理目前搜索节点出发的路径
一般就是一个for循环的操作，去遍历目前搜索节点所能到的所有节点
```C++
for (选择: 本节点所连接的其他节点){
    处理节点;
    dfs(图，选择的节点);//递归
    回溯,撤销处理结果;
}
```



# 广度优先搜索理论基础
广搜是一圈一圈的搜索，深搜是一条路跑到黑然后再回溯

广搜的搜索方式就适合于解决两个点之间的最短路径问题,因为BFS只要搜索到终点一定是一条最短路径(这里面还可以包括障碍)


广搜是如何做到的？其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，用队列，栈，数组都是可以的

用队列的话，就是保证每一圈都是一个方向去转
用栈的话，就是第一圈顺时针，第二圈逆时针,第三圈再顺时针(因为栈是先进后出，加入元素和弹出元素的顺序改变了)


广搜代码模板:
```c++
int dir[4][2]={0,1,1,0,-1,0,0,-1};//表示四个方向
//grid是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>&visited,int x,int y){
    queue<pair<int,int>> que; //定义队列
    que.push({x,y}); //起点加入队列
    visited[x][y]=true; //只要加入队列，立刻标记为访问过的节点
    while(!que.empty()){
        pair<int,int> cur = que.front(); que.pop(); //从队列中取出元素
        int curx = cur.first; 
        int cury = cur.second; //当前节点坐标
        for (int i=0; i<4; i++){ //开始向当前节点的四个方向左右上下去遍历
            int nextx=curx+dir[i][0];
            int nexty = cury+dir[i][1];//获取周边四个方向的坐标
            if (nextx<0 || nextx>=grid.size()|| nexty<0 || nexty>=grid[0].size())  continue;
            if (!visited[nextx][nexty]){ //如果节点没有被访问过
                que.push({nextx,nexty}); //队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty]=true; //只要入队立刻标记，避免重复访问
            }

        }
    }
    
}
```
