# dfs和bfs的区别
两者大概的区别:
dfs是可一个方向去搜索，不到黄河不回头，知道遇到绝境了，搜不下去了，再换方向(换方向的过程就涉及到了回溯).
bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，西面八方的搜索过程


# dfs关键就两点:
1. 搜索方向，是认准一个方向搜，直到碰壁后再换方向
2. 换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程


# 代码框架
正是因为dfs搜索是可一个方向，并需要回溯，所以用递归的方式来实现是最方便的
```C++
void dfs(参数){
    处理节点
    dfs(图，选择的节点);//递归
    回溯，撤销处理结果
}
```
回溯操作就在递归函数的下面，递归和回溯是相辅相成的

dfs和bfs其实就是基础搜索语法，广泛应用于其他数据结构与算法中.
```c++
void dfs(参数){
    if(终止条件){
        存放结果;
        return ;
    }
    for( 选择:本节点所连接的其他节点){
        处理节点;
        dfs(图，选择的节点);//递归
        回溯，撤销处理结果
    }
}
```

# 深搜三部曲
第一:
确认递归函数，参数
```c++
void dfs(参数)
```
一般情况，深搜需要二维数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量,避免函数过多
```c++
vector<vector<int>> result; //保存符合条件的所有路径
vector<int> path; //起点到终点的路径
void dfs(图，目前搜索的节点)
```
第二:
确认终止条件
```c++
if (终止条件){
    存放结果;
    return ;
}
```
终止条件不仅是结束本层递归,同时也是我们收获结果的时候
有很多dfs写法，没有写终止条件，是因为如果不符合条件的话，直接不会向下递归

第三:
处理目前搜索节点出发的路径
一般就是一个for循环的操作，去遍历目前搜索节点所能到的所有节点
```C++
for (选择: 本节点所连接的其他节点){
    处理节点;
    dfs(图，选择的节点);//递归
    回溯,撤销处理结果;
}
```

































