"""

154.寻找旋转排序数组中的最小值||

已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。例如，原数组nums = [0,1,4,4,5,6,7]在变化后可能得到:
    - 若旋转4次，则可以得到[4,5,6,7,0,1,4]
    - 若旋转7次，则可以得到[0,1,4,4,5,6,7]

注意，数组[a[0],a[1],a[2],...,a[n-1]]旋转一次的结果为[a[n-1],a[0],a[1],a[2],...,a[n-2]]。

给你一个可能存在重复元素值的数组nums，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。

你必须尽可能减少整个过程的操作步骤。

对于旋转后的排序数组，主要有以下三种情况:
1. 数组中间元素小于右边界的元素:
    说明最小值在左半部分，或者中间元素本身就是最小值。因此可以移动右边界到中间元素位置。
2. 数组中间元素大于右边界的元素:
    说明最小值在右半部分，应该移动左边界到mid+1
3. 数组中间元素等于右边界的元素:
    由于重复值的存在，这种情况无法直接判断，最好的策略是逐步缩小右边界，排除掉重复值，继续查找。

"""

from typing import List
class Solution:
    def findMin(self,nums:List[int])->int:
        # 二分查找
        left = 0
        right = len(nums)-1

        while left < right:
            mid = left + (right-left)//2
            
            # 开始判断
            if nums[mid]>nums[right]: # 最小值在右边
                left = mid+1
            elif nums[mid]<nums[right]: # 最小值在左边或者mid
                right = mid
            else: # 等于就要删掉最右边的干扰值
                right = right-1

        return nums[left]













