"""
Floyd算法精讲

小明喜欢去公园散布，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径
给定一个公园景点图，图中有N个景点(编号1到N)，以及M条双向道路连接着这些景点。每条道路上行走的距离都是已知的。
小明有Q个观景计划，每个计划都有一个起点start和一个终点end,表示他想从景点start前往景点end.由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。请你帮助小明计算出每个观景计划的最短路径长度

输入描述:
第一行包含两个整数N，M，分别表示景点的数量和道路的数量。
接下来的M行，每行包含三个整数u,v,w,表示景点u和景点v之间有一条长度为w的双向道路
接下来的一行包含一个整数Q，表示观景计划的数量
接下来的Q行，每行包含两个整数start,end,表示一个观景计划的起点和终点

输出描述:
对于每个观景计划，输出一行表示从起点到终点的最短路径长度，如果两个景点之间不存在路径，则输出-1

"""

"""
回归本质动态规划:
dp数组: dp[i][j][k] :表示从节点i到节点j的最短距离 ,这里的k的意思是允许作为中间节点的编号集合(1...k)

比如说
dp[i][j][0],表示i到j不允许有中间节点的最短距离
dp[i][j][1],表示i到j允许以节点1为中间节点的最短距离
dp[i][j][1],表示i到j允许以节点1,2为中间节点的最短距离
dp[i][j][k],表示i到j允许以节点1,2...k为中间节点的最短距离

我们是按序逐步扩展中间节点的范围

这样的话，我们的第推公式就是:
对于任何一个中间节点k，我们更新dp[i][j]的时候，只会有两种情况

1. 我们选择取这个中间节点k, 那么dp[i][j][k]=dp[i][k][k-1]+dp[k][j][k-1] ,
2. 继承，我们不取这个k,那相当于结果就是dp[i][j][k]=dp[i][j][k-1]

这里我们要明白的是，我们每一轮，都会更新出单前允许中间范围的最优dp[i][j],怎么说呢？也就是随着我们给的中间节点范围的不断扩大，会越来越优化i 到j的最短路径

初始化:
最开始的数据肯定是没有中间节点
dp[i][j][0]=无限大,然后根据输入来初始化dp[i][j][0],然后由k=0,依次往后推出k从1-N

遍历顺序,很明显，我们第推公式中依赖k-1的所有数据，所以外层k,里面两层i,j,顺序无所谓


空间优化：
对于dp[i][j][k]=dp[i][k][k-1]+dp[k][j][k-1] ,
如果计算dp[i][j]用到了本层中刚好计算到的dp[i][k]有什么问题?
在Floyd算法中，计算是逐步推进的，允许的中间节点越多，理论上路径越优. 用更短的取优化当然没有任何问题,并且由3维的第推公式可以看出，dp[i][k]只会每次更新优化，不会出现这一层比上一层大的情况,所以我们完全可以用本层的dp[i][k] dp[k][j]代替上一层

所以dp[i][j]= min(dp[i][k]+dp[k][j],dp[i][j])


"""

if __name__=="__main__":
    n,m =map(int,input().split())
    max_int = 10005 #设置最大路径，因为边最大距离为10000
    #二维数组
    graph = [[max_int]*(n+1) for _ in range(n+1)]

    #初始化
    for _ in range(m):
        s,t,v = map(int,input().split())
        graph[s][t] = v
        graph[t][s] = v

    for k in range(1,n+1):
        for i in range(1,n+1):
            for j in range(1,n+1):
                graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j])

    for i in range(int(input())):
        s,t= map(int,input().split())
        if graph[s][t]!=max_int:
            print(graph[s][t])
        else:
            print(-1)

        







