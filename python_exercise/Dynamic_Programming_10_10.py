"""
给定一个由正整数组成且不存在重复数字的数组.找出和为给定目标正整数的组合的个数
nums=[1,2,3]
target=4
注意:顺序不同的序列被视作不同的组合

这就是很明显的一个排列的问题
现在来看为什么外层是背包,内层是物品就是排列
当我们遍历到背包j=3时候
先遍历硬币1: dp[3-1],那就是dp[2]里面有[1,1],[2] ,所以dp[3]有两种:[1,1,1],[2,1]
后遍历硬币2: dp[3-2],那就是dp[1]里面有[1],所以dp[3]有一种:[1,2]
最后遍历硬币3:dp[3-3],那就是dp[0]初始化成了1,所以dp[3]有一种:[3]
此时我们发现,我们把[1,2]和[2,1]当成了两种,所以是排列

再看外层物品,内层背包
遍历到物品1时候:
背包会从0-target都放好,把所有的背包尽可能装满
dp[3]只能是[1,1,1] dp[2]是[1,1] dp[1]是[1] dp[0]初始成了1
然后现在下一层物品2时遍历背包:
dp[0]=1 dp[1]=1 dp[2]更新有了[1,1]和[2] 然后现在dp[3]=dp[3-2]=dp[1]=1 就是[1,2]
然后下一层物品3时候
dp[0]=1 dp[1]=1 dp[2]=2 有[1,1]和[2] 然后现在dp[3]=dp[3-3]=dp[0] =1 就是[3]
所以只有[1,1,1] [1,2] [3]
我们发现这种不可能会出现[2,1] 这种情况所以它是组合
"""

from typing import List

class Solution():
    def combinationSum4(self,nums:List[int],target:int)->int:
        #dp数组
        dp=[0]*(target+1)
        #初始化
        dp[0]=1

        #是排列
        for j in range(0,target+1):
            for num in nums:
                if j>=num:
                    dp[j]+=dp[j-num]
        return dp[target]












